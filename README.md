# GitHub Action Using Cosign to Sign and Image
The example github action in:
```
.github/workflows/cosign.yaml
```

Provides an example workflow of:
- Building an image using the Dockerfile in the root directory
  - Chainctl github action is used to provide auth to the private Chainguard registry see this [link](https://edu.chainguard.dev/chainguard/administration/assumable-ids/identity-examples/github-identity/) for details.
- Pushing that image to a github container registry
- Signing the image with cosign
- Pushing the signature to the github registry

The example shows two ways to sign the image using cosign:
## Example 1 - Signing with an externally provided key
```
      # Sign using an externally generated key
      - name: Sign image with Cosign Using Provided Key
        run: |
          echo "github signing key: ${GHSIGNINGKEY}"
          echo "github signing key2: ${GHSIGNINGKEY2}"
          images=""
          for tag in ${TAGS}; do
            images+="${tag}@${DIGEST} "
          done
          if [ "${GHSIGNINGKEY}" = true ] ; then
            cosign sign --yes ${images}
          else
            cosign sign --yes --key env://COSIGN_PRIVATE_KEY ${images}
          fi
        env:
          TAGS: ${{ steps.docker_meta.outputs.tags }}
          COSIGN_PRIVATE_KEY: ${{ secrets.COSIGN_PRIVATE_KEY }}
          COSIGN_PASSWORD: ${{ secrets.COSIGN_PASSWORD }}
          DIGEST: ${{ steps.build-and-push.outputs.digest }}

```
In the first example the key used to sign the image is provided externally and stored as a secret for the action.  The password for the key is also stored as a secret.  In this example the key was geneated using cosign and the following command:
```
cosign generate-key-pair
```

The output of the above command will generate 2 files:
- cosign.key - The contents of this file is the encrypted private key that is stored in the COSIGN_PRIVATE_KEY secret
- cosign.pub - This is the public key that isn't used for signing, but is used to verify the signature (see below)

When running the cosign generate-key-pair command you are prompted for a password that is used to encypt the private key. That password is stored in another secret called COSIGN_PASSWORD for the action.

To verify the signature:
```
cosign verify --key cosign.pub ghcr.io/<GITHUB ORG NAME>/<GITHUB_REPO>:sha-<IMAGE HASH>
```
An example of the rekor logs using this approach is [here](https://search.sigstore.dev/?logIndex=181872174) 

## Example 2 - Signing the Key with GitHub key
The second example shown here:
```
      # Sign using GitHub easier setup, but embeds a bunch of information into the certificate that ends up in the rekor logs that some may not like.:
      - name: Sign the images using GitHub Key
        env:
           DIGEST: ${{ steps.build-and-push.outputs.digest }}
           TAGS: ${{ steps.docker_meta.outputs.tags }}
        run: |
           images=""
           for tag in ${TAGS}; do
             images+="${tag}@${DIGEST} "
           done
           cosign sign --yes ${images}
```

Uses a key generated by GitHub, while this is much easier to set up, there is a lot of GitHub data embedded into the public key that some may not want appearing in the Rekor logs (example below).

To verify a signature using this approach you can use the following command:
```
cosign verify \
    --certificate-identity https://github.com/<GITHUB ORG NAME>/<GITHUB REPO NAME>/.github/workflows/<GITHUB REPO NAME>.yaml@refs/heads/<BRANCH NAME> \
    --certificate-oidc-issuer https://token.actions.githubusercontent.com \
    ghcr.io/<GITHUB ORG NAME>/<GITHUB REPO NAME>:sha-<IMAGE HASH>
```
An example of the rekor logs using this approach is [here](https://search.sigstore.dev/?logIndex=181872195) 


